# =============================================================
# CI/CD Pipeline - 2COVID-19_Complete_ETL_Pipeline
# =============================================================
# Flujo:
#   1. [CI] En cada push: instala deps + corre 22 pytest locales
#   2. [CD] Si tests pasan en main: deploya notebooks a Databricks
#              y lanza el job 2COVID-19_Complete_ETL_Pipeline
#
# Secrets requeridos en GitHub (Settings > Secrets > Actions):
#   - DATABRICKS_HOST  : https://dbc-6100158f-36ab.cloud.databricks.com
#   - DATABRICKS_TOKEN : token personal de acceso de Databricks
# =============================================================

name: COVID-19 Pipeline CI/CD

on:
  push:
    branches: [ "**" ]
  pull_request:
    branches: [ main ]

env:
  DATABRICKS_HOST: ${{ secrets.DATABRICKS_HOST }}
  DATABRICKS_TOKEN: ${{ secrets.DATABRICKS_TOKEN }}
  DATABRICKS_JOB_ID: "762347435635648"
  WORKSPACE_PATH: "/Workspace/Users/joojle95@gmail.com/covid workflow opt"
  PYTHON_VERSION: "3.11"

jobs:

  # ===========================================================
  # JOB 1: CI - Tests locales con pytest
  # ===========================================================
  test:
    name: Run Local Tests (pytest)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout codigo
        uses: actions/checkout@v4

      - name: Configurar Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: "pip"

      - name: Instalar dependencias
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Verificar estructura del proyecto
        run: |
          echo "=== Estructura del repo ==="
          find . -type f -name "*.py" | grep -v __pycache__ | sort
          echo "=== Archivos de config ==="
          ls configs/

      - name: Ejecutar tests locales con pytest
        run: |
          pytest tests/test_pipeline_local.py \
            --verbose \
            --tb=short \
            --no-header \
            -rN \
            --color=yes

      - name: Mostrar resumen de tests
        if: always()
        run: |
          echo "Tests completados en branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"

  # ===========================================================
  # JOB 2: CD - Deploy a Databricks
  # Solo se ejecuta si tests pasaron Y es push a main
  # ===========================================================
  deploy:
    name: Deploy to Databricks & Run Job
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout codigo
        uses: actions/checkout@v4

      - name: Configurar Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: "pip"

      - name: Instalar Databricks CLI (legacy)
        run: |
          pip install databricks-cli
          databricks --version
          databricks jobs configure --version=2.1

      - name: Configurar autenticacion Databricks
        env:
          DB_HOST: ${{ secrets.DATABRICKS_HOST }}
          DB_TOKEN: ${{ secrets.DATABRICKS_TOKEN }}
        run: |
          mkdir -p "$(dirname ~/.databrickscfg)"
          printf '[DEFAULT]\nhost = %s\ntoken = %s\n' "$DB_HOST" "$DB_TOKEN" > ~/.databrickscfg

      - name: Verificar conexion a Databricks
        run: |
          databricks workspace ls /Workspace/Users/joojle95@gmail.com/ 2>&1 | head -20

      - name: Desplegar notebook Bronze to Silver
        run: |
          databricks workspace import \
            notebooks/covid_bronze_to_silver_workflow_opt.py \
            "${{ env.WORKSPACE_PATH }}/covid_bronze_to_silver_workflow_opt" \
            --language PYTHON \
            --format SOURCE \
            --overwrite
          echo "[OK] bronze_to_silver desplegado"

      - name: Desplegar notebook Silver to Gold
        run: |
          databricks workspace import \
            notebooks/covid_silver_to_gold_workflow_opt.py \
            "${{ env.WORKSPACE_PATH }}/covid_silver_to_gold_workflow_opt" \
            --language PYTHON \
            --format SOURCE \
            --overwrite
          echo "[OK] silver_to_gold desplegado"

      - name: Desplegar notebook de Tests
        run: |
          databricks workspace import \
            notebooks/covid_testing_bronze_to_silver.py \
            "${{ env.WORKSPACE_PATH }}/covid_testing_bronze_to_silver" \
            --language PYTHON \
            --format SOURCE \
            --overwrite
          echo "[OK] testing notebook desplegado"

      - name: Lanzar Job en Databricks via REST API
        id: run_job
        env:
          DB_HOST: ${{ secrets.DATABRICKS_HOST }}
          DB_TOKEN: ${{ secrets.DATABRICKS_TOKEN }}
        run: |
          RESPONSE=$(curl -s -X POST \
            "${DB_HOST}/api/2.1/jobs/run-now" \
            -H "Authorization: Bearer ${DB_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"job_id\": ${{ env.DATABRICKS_JOB_ID }}}")
          echo "Response: $RESPONSE"
          RUN_ID=$(echo "$RESPONSE" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('run_id',''))")
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          echo "[OK] Job lanzado con run_id=$RUN_ID"

      - name: Esperar resultado del Job via REST API
        id: wait_job
        env:
          DB_HOST: ${{ secrets.DATABRICKS_HOST }}
          DB_TOKEN: ${{ secrets.DATABRICKS_TOKEN }}
        run: |
          RUN_ID="${{ steps.run_job.outputs.run_id }}"
          echo "Esperando run_id=$RUN_ID ..."
          MAX_WAIT=1800
          ELAPSED=0
          INTERVAL=30
          RESULT_STATE=""
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STATUS=$(curl -s \
              "${DB_HOST}/api/2.1/jobs/runs/get?run_id=${RUN_ID}" \
              -H "Authorization: Bearer ${DB_TOKEN}")
            LIFE_CYCLE=$(echo "$STATUS" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('state',{}).get('life_cycle_state',''))")
            RESULT_STATE=$(echo "$STATUS" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('state',{}).get('result_state',''))" 2>/dev/null || echo "")
            echo "[$(date +%H:%M:%S)] life_cycle=$LIFE_CYCLE | result=$RESULT_STATE | elapsed=${ELAPSED}s"
            if [ "$LIFE_CYCLE" = "TERMINATED" ]; then
              echo "result_state=$RESULT_STATE" >> $GITHUB_OUTPUT
              if [ "$RESULT_STATE" = "SUCCESS" ]; then
                echo "[OK] Job completado exitosamente!"
                exit 0
              else
                echo "[FAIL] Job fallo con estado: $RESULT_STATE"
                exit 1
              fi
            fi
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          echo "[TIMEOUT] Job no termino en ${MAX_WAIT}s"
          exit 1

      - name: Resumen del deploy
        if: always()
        run: |
          echo "====================================="
          echo "  Deploy Summary"
          echo "====================================="
          echo "Branch    : ${{ github.ref_name }}"
          echo "Commit    : ${{ github.sha }}"
          echo "Actor     : ${{ github.actor }}"
          echo "Run ID    : ${{ steps.run_job.outputs.run_id }}"
          echo "Job Result: ${{ steps.wait_job.outputs.result_state }}"
          echo "====================================="
